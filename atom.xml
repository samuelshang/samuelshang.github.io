<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>闻道有先后,术业有专攻</title>
  
  <subtitle>一万个小时理论坚定拥趸者</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://samuelshang.github.io/"/>
  <updated>2019-08-12T08:46:08.000Z</updated>
  <id>https://samuelshang.github.io/</id>
  
  <author>
    <name>Samuel shang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据流管理程</title>
    <link href="https://samuelshang.github.io/2019/08/12/%E6%95%B0%E6%8D%AE%E6%B5%81%E7%AE%A1%E7%90%86%E7%A8%8B/"/>
    <id>https://samuelshang.github.io/2019/08/12/数据流管理程/</id>
    <published>2019-08-12T08:45:26.000Z</published>
    <updated>2019-08-12T08:46:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>数据变化，反应到页面</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;数据变化，反应到页面&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>node入门</title>
    <link href="https://samuelshang.github.io/2019/04/28/node%E5%85%A5%E9%97%A8/"/>
    <id>https://samuelshang.github.io/2019/04/28/node入门/</id>
    <published>2019-04-28T08:37:23.000Z</published>
    <updated>2019-04-28T08:38:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>##了解</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##了解&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>js异步编程</title>
    <link href="https://samuelshang.github.io/2019/04/19/js%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    <id>https://samuelshang.github.io/2019/04/19/js异步编程/</id>
    <published>2019-04-19T01:30:56.000Z</published>
    <updated>2019-08-11T15:18:46.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="js异步的实现"><a href="#js异步的实现" class="headerlink" title="js异步的实现"></a>js异步的实现</h3><p>基于事件循环的并发模型，函数可以作为变量传入其他函数，等函数执行时顺序调用回调函数</p><h4 id="回调函数存在的问题"><a href="#回调函数存在的问题" class="headerlink" title="回调函数存在的问题"></a>回调函数存在的问题</h4><ul><li><p>剥夺了使用 <code>return</code> 和 <code>throw</code> 这些关键字的能力。相反整个代码流程都是基于副作用的: 一个函数会附带调用其他函数。</p></li><li><p>回调地狱：难以维护和复用</p></li><li><p>多个异步计算同时进行，无法预期完成顺序，必须借助外层作用域的变量，有误操作风险</p></li><li><p>破坏调用栈</p><blockquote><p>函数执行是一个“入栈/出栈”的过程。当我们在 A 函数里调用 B 函数的时候，JS 引擎就会先把 A 压到栈里，然后再把 B 压到栈里；B 运行结束后，出栈，然后继续执行 A；A 也运行完毕后，出栈，栈已清空，这次运行结束。中断代码执行，可以检索完整的堆栈，完整的作用域链（闭包），获取信息。可是异步回调函数不完全如此，都不会直接调用回调函数，而是继续执行其它代码，直至完成，出栈。真正调用回到函数的是引擎，并且是启用一个新栈，压入栈成为第一个函数。所以如果回调报错，无法获取之前启动异步计算时栈里的信息，无法捕获回调函数抛出的错误,不容易判定什么导致了错误</p></blockquote></li></ul><h4 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h4><p>then接受的是两个函数作为参数</p><ol><li><code>return</code> 另一个 promise</li><li><code>return</code> 一个同步的值 (或者 <code>undefined</code>)</li><li><code>throw</code> 一个同步异常</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>).then(<span class="built_in">Promise</span>.resolve(<span class="string">'bar'</span>)).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo 而不是bar</span></span><br><span class="line"></span><br><span class="line"> then() 传递的并非是一个函数（比如 promise），它实际上会将其解释为 then(<span class="literal">null</span>)，这就会导致前一个 promise 的结果会穿透下面</span><br></pre></td></tr></table></figure><p>存在的问题：</p><p>只能解决代码不好阅读，不易维护的问题，面对语言本身的问题，它也无能为力。异步回调在执行的时候，会切断前后栈的联系。</p><p> Promise 的执行器只能捕获到异步函数抛出的错误，无法捕获回调函数抛出的错误。</p><p>异步函数（await/async）是新的语法，改变了运行时，所以可以继续检索堆栈，完全不会有这方面的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function b() &#123;</span><br><span class="line">  </span><br><span class="line">  let abc = 32;</span><br><span class="line">  return abc;</span><br><span class="line">&#125;</span><br><span class="line">function a() &#123;</span><br><span class="line">  b();</span><br><span class="line">  return 123;</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;js异步的实现&quot;&gt;&lt;a href=&quot;#js异步的实现&quot; class=&quot;headerlink&quot; title=&quot;js异步的实现&quot;&gt;&lt;/a&gt;js异步的实现&lt;/h3&gt;&lt;p&gt;基于事件循环的并发模型，函数可以作为变量传入其他函数，等函数执行时顺序调用回调函数&lt;/p&gt;
&lt;h4 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>react核心</title>
    <link href="https://samuelshang.github.io/2019/04/19/react%E6%A0%B8%E5%BF%83/"/>
    <id>https://samuelshang.github.io/2019/04/19/react核心/</id>
    <published>2019-04-19T01:29:34.000Z</published>
    <updated>2019-04-19T01:31:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>React.createElement();</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;React.createElement();&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>setTimeout setInterval</title>
    <link href="https://samuelshang.github.io/2018/04/18/setTimeout-setInterval/"/>
    <id>https://samuelshang.github.io/2018/04/18/setTimeout-setInterval/</id>
    <published>2018-04-18T13:05:06.000Z</published>
    <updated>2019-04-19T06:16:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="window下的方法主要用法"><a href="#window下的方法主要用法" class="headerlink" title="window下的方法主要用法"></a>window下的方法主要用法</h2><h4 id="1-阻塞异步执行"><a href="#1-阻塞异步执行" class="headerlink" title="1.阻塞异步执行"></a>1.阻塞异步执行</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果：1 秒之后，同时输出 5 个 5。同步循环已经执行完毕，才会执行事件队列里的回调</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; </span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;      <span class="comment">//立刻执行函数</span></span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i);  </span><br><span class="line">         &#125;,<span class="number">1000</span>);  </span><br><span class="line">    &#125;)(i);  <span class="comment">//闭包保存局部变量的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>promise异步会优先执行</p><h4 id="2-改变this的指向"><a href="#2-改变this的指向" class="headerlink" title="2.改变this的指向"></a>2.改变this的指向</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"pig"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"Hello,my name is "</span>+<span class="keyword">this</span>.name);</span><br><span class="line">        &#125;,<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> weiqi = <span class="keyword">new</span> Person(<span class="string">"卫旗"</span>);</span><br><span class="line">weiqi.getName();   <span class="comment">//pig</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"pig"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"Hello,my name is "</span>+<span class="keyword">this</span>.name);</span><br><span class="line">        &#125;.bind(<span class="keyword">this</span>),<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> weiqi = <span class="keyword">new</span> Person(<span class="string">"卫旗"</span>);</span><br><span class="line">weiqi.getName();   <span class="comment">//pig</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;window下的方法主要用法&quot;&gt;&lt;a href=&quot;#window下的方法主要用法&quot; class=&quot;headerlink&quot; title=&quot;window下的方法主要用法&quot;&gt;&lt;/a&gt;window下的方法主要用法&lt;/h2&gt;&lt;h4 id=&quot;1-阻塞异步执行&quot;&gt;&lt;a href
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue组件系统</title>
    <link href="https://samuelshang.github.io/2018/03/31/vue%E7%BB%84%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>https://samuelshang.github.io/2018/03/31/vue组件系统/</id>
    <published>2018-03-31T12:37:40.000Z</published>
    <updated>2018-03-31T12:53:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="组件（Component）是-Vue-js-最强大的功能之一"><a href="#组件（Component）是-Vue-js-最强大的功能之一" class="headerlink" title="组件（Component）是 Vue.js 最强大的功能之一"></a>组件（Component）是 Vue.js 最强大的功能之一</h2><h4 id="使用-slot-分发内容"><a href="#使用-slot-分发内容" class="headerlink" title="使用 slot 分发内容"></a>使用 slot 分发内容</h4><p><strong>开发过程中，常常需要在子组件内添加新的内容，这时候可以在子组件内部留一个或者多个插口 <slot></slot></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;slot&gt;</span><br><span class="line">        &lt;/slot&gt;</span><br><span class="line">        &lt;slot name=&quot;first&quot;&gt;&lt;/slot&gt;</span><br><span class="line">        &lt;slot name=&quot;second&quot;&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">然后在调用这个子组件的时候加入内容</span><br><span class="line">&lt;child-component&gt;</span><br><span class="line">    &lt;h1&gt;不具名slot插口&lt;/h1&gt;</span><br><span class="line">    &lt;h2 slot=&quot;first&quot;&gt;对应first插口&lt;/h2&gt;</span><br><span class="line">    &lt;h3 slot =&quot;second&quot;&gt;对应second插口&lt;h3&gt;</span><br><span class="line">&lt;/child-component&gt;</span><br></pre></td></tr></table></figure><p><strong><slot> 中还可以作为一个作用域，在子组件中定义变量，然后在父组件中自定义渲染的方式</slot></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p&gt;一个简单的组件&lt;/p&gt;</span><br><span class="line">        &lt;slot name=&quot;nav&quot; v-for=&quot;nav in navs&quot; :text=&quot;nav.text&quot;&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;child-component :navs=&quot;navs&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;template slot=&quot;nav&quot; scope=&quot;props&quot;&gt;</span><br><span class="line">    &lt;p&gt; &#123;&#123;props.text&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;/child-component&gt;</span><br><span class="line"></span><br><span class="line">这个示例中，首先在子组件中添加 &lt;slot&gt;，并在子组件中定义了数组变量 navs</span><br><span class="line"></span><br><span class="line">然后在父组件中以作用域 &lt;template&gt; 添加内容，其中 scope 是固有属性，它的值对应一个临时变量 props</span><br><span class="line"></span><br><span class="line">而 props 将接收从父组件传递给子组件的参数 navs</span><br></pre></td></tr></table></figure></p><h4 id="动态组件实现tab切换效果"><a href="#动态组件实现tab切换效果" class="headerlink" title="动态组件实现tab切换效果"></a>动态组件实现tab切换效果</h4><p>这样的功能可以通过路由 vue-router 实现，但路由更适合较大的组件，而且 url 会有相应的改变<br>Vue 自身保留的 <component> 元素，可以将组件动态绑定到 is 特性上，从而很方便的实现动态组件切换</component></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">    &lt;component v-bind=&quot;tab&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/component&gt;</span><br><span class="line"></span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 递归组件</span><br><span class="line"></span><br><span class="line">当组件拥有 name 属性的时候，就可以在它的模板内递归的调用自己，这在开发树形组件的时候十分有效</span><br></pre></td></tr></table></figure><template><br>    <div><br>        <p>一个简单的组件</p><br>        <simple></simple><br>    </div><br></template><p><script><br>    export default{<br>        name:simple<br>    }</p><p></script><br><code>`</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;组件（Component）是-Vue-js-最强大的功能之一&quot;&gt;&lt;a href=&quot;#组件（Component）是-Vue-js-最强大的功能之一&quot; class=&quot;headerlink&quot; title=&quot;组件（Component）是 Vue.js 最强大的功能之一&quot;&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>深入浅出REST</title>
    <link href="https://samuelshang.github.io/2018/03/30/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAREST/"/>
    <id>https://samuelshang.github.io/2018/03/30/深入浅出REST/</id>
    <published>2018-03-30T12:04:36.000Z</published>
    <updated>2018-03-30T13:06:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="REST定义了应该如何正确地使用Web标准，例如HTTP和URI。"><a href="#REST定义了应该如何正确地使用Web标准，例如HTTP和URI。" class="headerlink" title="REST定义了应该如何正确地使用Web标准，例如HTTP和URI。"></a>REST定义了应该如何正确地使用Web标准，例如HTTP和URI。</h3><p>如果你在设计应用程序时能坚持REST原则，那就预示着你将会得到一个使用了优质Web架构（这将让你受益）的系统。</p><ul><li>为所有“事物”定义ID</li><li>将所有事物链接在一起</li><li>使用标准方法</li><li>资源多重表述</li><li>无状态通信</li></ul><p>RESTful Web Service (又称 RESTful Web API) 是一个使用 HTTP 并符合 REST 原则的 Web 服务。我们知道，通过 URL 可以传送 HTTP请求进行状态转换。</p><p>在 RESTful 每个资源有自己独立的 URI， Client 从资源集合或单个资源开始进入，不管是资源集合或单个资源，我们都能与 HTTP 方法配合使用，例如，GET 下载，PUT 更新，POST 新增，DELETE 删除。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;REST定义了应该如何正确地使用Web标准，例如HTTP和URI。&quot;&gt;&lt;a href=&quot;#REST定义了应该如何正确地使用Web标准，例如HTTP和URI。&quot; class=&quot;headerlink&quot; title=&quot;REST定义了应该如何正确地使用Web标准，例如HT
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>web-service</title>
    <link href="https://samuelshang.github.io/2018/03/30/web-service/"/>
    <id>https://samuelshang.github.io/2018/03/30/web-service/</id>
    <published>2018-03-30T11:54:06.000Z</published>
    <updated>2018-03-30T12:03:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Web-Service简单地说-也就是服务器如何向客户端提供服务"><a href="#Web-Service简单地说-也就是服务器如何向客户端提供服务" class="headerlink" title="Web Service简单地说, 也就是服务器如何向客户端提供服务."></a>Web Service简单地说, 也就是服务器如何向客户端提供服务.</h2><p>常用的方法有:</p><ol><li><a href="http://en.wikipedia.org/wiki/Remote_procedure_call" target="_blank" rel="noopener">RPC</a> 所谓的远程过程调用 (面向方法)</li><li><a href="http://en.wikipedia.org/wiki/Service-oriented_architecture" target="_blank" rel="noopener">SOA</a> 所谓的面向服务的架构(面向消息)</li><li><a href="http://en.wikipedia.org/wiki/Representational_State_Transfer" target="_blank" rel="noopener">REST</a> 所谓的 <strong>Representational state transfer</strong> (面向资源)</li></ol><p><strong>RPC</strong></p><p>即远程过程调用, <strong>像调用本地服务(方法)一样调用服务器的服务(方法)</strong>.</p><p>通常的实现有 <a href="http://en.wikipedia.org/wiki/Xml-rpc" target="_blank" rel="noopener">XML-RPC</a> , <a href="http://en.wikipedia.org/wiki/JSON-RPC" target="_blank" rel="noopener">JSON-RPC</a> , 通信方式基本相同, 所不同的只是传输数据的格式.向服务器发送一个过程调用的方法及其参数, 得到服务器返回的方法执行的结果.</p><p><strong>REST</strong></p><p><a href="http://en.wikipedia.org/wiki/Representational_State_Transfer" target="_blank" rel="noopener">REST</a> 不是一种协议,它是一种架构, 远程通信方法，一种 <a href="http://en.wikipedia.org/wiki/Web_Service" target="_blank" rel="noopener">Web Service</a> 能够如果满足 <a href="http://en.wikipedia.org/wiki/Representational_State_Transfer" target="_blank" rel="noopener">REST</a> 的几个条件, 通常就称这个系统是 <em>Restful</em> 的.</p><ol><li>C/S结构 (这是Internet服务的一个基本特征)</li><li>无状态 (很熟悉吧,呵呵)</li><li>可以cache (想起了浏览器?)</li><li>分层系统 (想起了无数的架构?)</li><li>统一的接口 (如果这是可能的,程序员有福了, :D)</li><li>code on demand(可选, 其实是一种扩展性的要求)</li></ol><p><a href="http://en.wikipedia.org/wiki/Representational_State_Transfer" target="_blank" rel="noopener">REST</a> 的三个要素是 <strong>唯一的资源标识</strong>, <strong>简单的方法</strong> (此处的方法是个抽象的概念), <strong>一定的表达方式</strong>.</p><h1 id="RPC与REST的区别"><a href="#RPC与REST的区别" class="headerlink" title="[RPC与REST的区别]"></a>[RPC与REST的区别]</h1><p><strong>RPC是以动词为中心的, REST是以名词为中心的</strong>, 此处的 动词指的是一些方法, 名词是指资源.</p><p>  以动词为中心,意味着,当你要需要加入新功能时,你必须要添加更多的动词, 这时候服务器端需要实现 相应的动词(方法), 客户端需要知道这个新的动词并进行调用.</p><p>而以名词为中心, 假使我请求的是 hostname/friends/, 无论这个URI对应的服务怎么变化,客户端是无需 关注和更新的,而这种变化对客户端也是透明的.</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="[参考资料]"></a>[参考资料]</h1><ol><li><a href="http://en.wikipedia.org/wiki/Web_Service" target="_blank" rel="noopener">Web Service</a></li><li><a href="http://en.wikipedia.org/wiki/Service-oriented_architecture" target="_blank" rel="noopener">SOA</a></li><li><a href="http://en.wikipedia.org/wiki/Representational_State_Transfer" target="_blank" rel="noopener">REST</a></li><li><a href="http://en.wikipedia.org/wiki/Remote_procedure_call" target="_blank" rel="noopener">RPC</a></li><li><a href="http://en.wikipedia.org/wiki/Cloud_computing" target="_blank" rel="noopener">Cloud Computing</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Web-Service简单地说-也就是服务器如何向客户端提供服务&quot;&gt;&lt;a href=&quot;#Web-Service简单地说-也就是服务器如何向客户端提供服务&quot; class=&quot;headerlink&quot; title=&quot;Web Service简单地说, 也就是服务器如何向客户
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Angularjs中controller之间的通信</title>
    <link href="https://samuelshang.github.io/2017/12/26/Angularjs%E4%B8%ADcontroller%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/"/>
    <id>https://samuelshang.github.io/2017/12/26/Angularjs中controller之间的通信/</id>
    <published>2017-12-26T07:32:55.000Z</published>
    <updated>2017-12-26T07:42:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="在-Angular-中，Controller-之间通信的方式主要有三种："><a href="#在-Angular-中，Controller-之间通信的方式主要有三种：" class="headerlink" title="在 Angular 中，Controller 之间通信的方式主要有三种："></a>在 Angular 中，Controller 之间通信的方式主要有三种：</h2><ul><li>作用域继承:父 Controller 中的数据要为引用类型，不能是基本类型</li><li>注入服务: 把需要共享的数据注册为一个 <code>service</code>，在需要的 Controller 中入。</li><li>基于事件。利用 Angular 的事件机制，使用 <code>$on</code>、<code>$emit</code> 和 <code>$boardcast</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;在-Angular-中，Controller-之间通信的方式主要有三种：&quot;&gt;&lt;a href=&quot;#在-Angular-中，Controller-之间通信的方式主要有三种：&quot; class=&quot;headerlink&quot; title=&quot;在 Angular 中，Controll
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>web路由</title>
    <link href="https://samuelshang.github.io/2017/09/17/web%E8%B7%AF%E7%94%B1/"/>
    <id>https://samuelshang.github.io/2017/09/17/web路由/</id>
    <published>2017-09-17T11:08:00.000Z</published>
    <updated>2017-09-17T11:25:09.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>什么是路由？</p></blockquote><hr><p>在Web开发过程中，经常会遇到『路由』的概念。那么，到底什么是路由？简单来说，路由就是 URL 到函数的映射。</p><h2 id="router-和-route-的区别"><a href="#router-和-route-的区别" class="headerlink" title="router 和 route 的区别"></a>router 和 route 的区别</h2><p>route 就是一条路由，它将一个 URL 路径和一个函数进行映射， router 可以理解为一个容器，或者说一种机制，它管理了一组 route。<br>     当接收到一个 URL 之后，去路由映射表中查找相应的函数，这个过程是由 router 来处理的</p><h1 id="服务器端路由"><a href="#服务器端路由" class="headerlink" title="服务器端路由"></a>服务器端路由</h1><p>   对于服务器来说，当接收到客户端发来的 HTTP 请求，会根据请求的 URL，来找到相应的映射函数，然后执行该函数，并将函数的返回值发送给客户端。对于最简单的静态资源服务器，可以认为，所有 URL 的映射函数就是一个文件读取操作。对于动态资源，映射函数可能是一个数据库读取操作</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> app.get(&apos;/&apos;, (req, res) =&gt; &#123;</span><br><span class="line">  res.sendFile(&apos;index&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">app.get(&apos;/users&apos;, (req, res) =&gt; &#123;</span><br><span class="line">  db.queryAllUsers()</span><br><span class="line">    .then(data =&gt; res.send(data))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>当访问 / 的时候，会返回 index 页面</li><li>当访问 /users 的时候，会从数据库中取出所有用户数据并返回<br>不仅仅是 URL。在 router 匹配 route 的过程中，不仅会根据 URL 来匹配，还会根据请求的方法来看是否匹配。例如上面的例子，如果通过 POST 方法来访问 /users，就会找不到正确的路由。</li></ul><h1 id="客户端路由"><a href="#客户端路由" class="headerlink" title="客户端路由"></a>客户端路由</h1><hr><p><strong>对于客户端（通常为浏览器）来说，路由的映射函数通常是进行一些 DOM 的显示和隐藏操作。这样，当访问不同的路径的时候，会显示不同的页面组件。客户端路由最常见的有以下两种实现方案：(1). 基于 Hash，(2). 基于 History API。</strong></p><ol><li>基于hash值，hash 仅仅是客户端的一个状态，也就是说，当向服务器发请求的时候，hash 部分并不会发过去。通过监听 window 对象的 hashChange 事件，可以实现简单的路由。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">window.onhashchange = function() &#123;</span><br><span class="line">  var hash = window.location.hash</span><br><span class="line">  var path = hash.substring(1)</span><br><span class="line">  switch (path) &#123;</span><br><span class="line">    case &apos;/&apos;:</span><br><span class="line">      showHome()</span><br><span class="line">      break</span><br><span class="line">    case &apos;/users&apos;:</span><br><span class="line">      showUsersList()</span><br><span class="line">      break</span><br><span class="line">    default:</span><br><span class="line">      show404NotFound()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>2.基于HTML5 History API 通过HTML5 History API可以在不刷新页面的情况下，直接改变当前URL,我们可以通过监听window对象的popstate事件，来实现简单的路由：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">window.onpopstate = function() &#123;</span><br><span class="line">  var path = window.location.pathname</span><br><span class="line">  switch (path) &#123;</span><br><span class="line">    case &apos;/&apos;:</span><br><span class="line">      showHome()</span><br><span class="line">      break</span><br><span class="line">    case &apos;/users&apos;:</span><br><span class="line">      showUsersList()</span><br><span class="line">      break</span><br><span class="line">    default:</span><br><span class="line">      show404NotFound()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;什么是路由？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;在Web开发过程中，经常会遇到『路由』的概念。那么，到底什么是路由？简单来说，路由就是 URL 到函数的映射。&lt;/p&gt;
&lt;h2 id=&quot;router-和-route-的区别&quot;&gt;&lt;a 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>js对Date日期的使用和处理</title>
    <link href="https://samuelshang.github.io/2017/09/14/js%E5%AF%B9Date%E6%97%A5%E6%9C%9F%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%A4%84%E7%90%86/"/>
    <id>https://samuelshang.github.io/2017/09/14/js对Date日期的使用和处理/</id>
    <published>2017-09-14T02:59:58.000Z</published>
    <updated>2017-09-14T03:00:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>new Date();</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;new Date();&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>登录验证</title>
    <link href="https://samuelshang.github.io/2017/09/14/%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81/"/>
    <id>https://samuelshang.github.io/2017/09/14/登录验证/</id>
    <published>2017-09-13T23:17:17.000Z</published>
    <updated>2017-09-15T22:52:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>监听 ui-router 的 state 事件可以实现当 state 切换的时候检查登录情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//添加事件监听</span><br><span class="line">    $rootScope.$on(&apos;$stateChangeStart&apos;, function(event, toState, toParams, fromState, fromParams) &#123;</span><br><span class="line">        if (toState.name == &apos;register&apos;) return; // 如果是进入登录界面则允许</span><br><span class="line">        // 如果用户不存在</span><br><span class="line">        if (!$rootScope.session || !$rootScope.seccion.session_id) &#123;</span><br><span class="line">        //if(!$rootScope.user || !$rootScope.user.token)&#123;</span><br><span class="line">            event.preventDefault(); // 取消默认跳转行为</span><br><span class="line">            $state.go(&quot;register&quot;, &#123; from: fromState.name, w: &apos;notLogin&apos; &#125;); //跳转到登录界面</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p><p>使用拦截器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//register interceptor as sercice</span><br><span class="line">app.factory(&apos;UserInterceptor&apos;, [&quot;$q&quot;,&quot;$rootScope&quot;,function ($q,$rootScope) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        request:function(config)&#123;</span><br><span class="line">            config.headers[&quot;TOKEN&quot;] = $rootScope.user.token;</span><br><span class="line">            return config;</span><br><span class="line">        &#125;,</span><br><span class="line">        responseError: function (response) &#123;</span><br><span class="line">            var data = response.data;</span><br><span class="line">            // 判断错误码，如果是未登录</span><br><span class="line">            if(data[&quot;errorCode&quot;] == &quot;500999&quot;)&#123;</span><br><span class="line">                // 清空用户本地token存储的信息，如果</span><br><span class="line">                $rootScope.user = &#123;token:&quot;&quot;&#125;;</span><br><span class="line">                // 全局事件，方便其他view获取该事件，并给以相应的提示或处理</span><br><span class="line">                $rootScope.$emit(&quot;userIntercepted&quot;,&quot;notLogin&quot;,response);</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果是登录超时</span><br><span class="line">            if(data[&quot;errorCode&quot;] == &quot;500998&quot;)&#123;</span><br><span class="line">                $rootScope.$emit(&quot;userIntercepted&quot;,&quot;sessionOut&quot;,response);</span><br><span class="line">            &#125;</span><br><span class="line">            return $q.reject(response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;]);</span><br><span class="line">//push interceptor to interceptor list</span><br><span class="line">app.config(function ($httpProvider) &#123;</span><br><span class="line">    $httpProvider.interceptors.push(&apos;UserInterceptor&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">$rootScope.$on(&apos;userIntercepted&apos;,function(errorType)&#123;</span><br><span class="line">    // 跳转到登录界面，这里我记录了一个from，这样可以在登录后自动跳转到未登录之前的那个界面</span><br><span class="line">    $state.go(&quot;login&quot;,&#123;from:$state.current.name,w:errorType&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>用户已经登录，但是登录超时了，还有就是增加后台接口的判断来增强安全性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">app.factory(&apos;UserInterceptor&apos;, [&quot;$q&quot;,&quot;$rootScope&quot;,function ($q,$rootScope) &#123;</span><br><span class="line">return &#123;</span><br><span class="line">        request:function(config)&#123;</span><br><span class="line">            config.headers[&quot;TOKEN&quot;] = $rootScope.user.token;</span><br><span class="line">            return config;</span><br><span class="line">        &#125;,</span><br><span class="line">        responseError: function (response) &#123;</span><br><span class="line">            var data = response.data;</span><br><span class="line">// 判断错误码，如果是未登录</span><br><span class="line">            if(data[&quot;errorCode&quot;] == &quot;500999&quot;)&#123;</span><br><span class="line">// 清空用户本地token存储的信息，如果</span><br><span class="line">                $rootScope.user = &#123;token:&quot;&quot;&#125;;</span><br><span class="line">// 全局事件，方便其他view获取该事件，并给以相应的提示或处理</span><br><span class="line">                $rootScope.$emit(&quot;userIntercepted&quot;,&quot;notLogin&quot;,response);</span><br><span class="line">            &#125;</span><br><span class="line">// 如果是登录超时</span><br><span class="line">if(data[&quot;errorCode&quot;] == &quot;500998&quot;)&#123;</span><br><span class="line">                $rootScope.$emit(&quot;userIntercepted&quot;,&quot;sessionOut&quot;,response);</span><br><span class="line">            &#125;</span><br><span class="line">            return $q.reject(response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;]);</span><br></pre></td></tr></table></figure></p><p>最后在 controller 中处理错误事件<br>$rootScope.$on(‘userIntercepted’,function(errorType){<br>    // 跳转到登录界面，这里我记录了一个from，这样可以在登录后自动跳转到未登录之前的那个界面<br>    $state.go(“login”,{from:$state.current.name,w:errorType});<br>});<br>Deprecation warning: use TransitionService.onStart instead</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;监听 ui-router 的 state 事件可以实现当 state 切换的时候检查登录情况&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue组件设计</title>
    <link href="https://samuelshang.github.io/2017/09/12/vue%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1/"/>
    <id>https://samuelshang.github.io/2017/09/12/vue组件设计/</id>
    <published>2017-09-12T14:12:37.000Z</published>
    <updated>2017-09-12T14:13:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>vue 的组件一般分为如下 4 种:</p><p>1.接入型 比如说一个容器组件, 它里面包含了其他的组件，它本身只承担一个布局容器的作用<br>2.展示型 纯展示型的数据，它能接收数据，展示出来，但是无法与用用户进行交互<br>3.交互型 比如各类加强版的表单组件，通常强调复用<br>4.功能型 比如 <router-view>，<transition>，作为一种扩展、抽象机制存在。</transition></router-view></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;vue 的组件一般分为如下 4 种:&lt;/p&gt;
&lt;p&gt;1.接入型 比如说一个容器组件, 它里面包含了其他的组件，它本身只承担一个布局容器的作用&lt;br&gt;2.展示型 纯展示型的数据，它能接收数据，展示出来，但是无法与用用户进行交互&lt;br&gt;3.交互型 比如各类加强版的表单组件，通常
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>angularjs开发过程中的问题及相关应用</title>
    <link href="https://samuelshang.github.io/2017/09/12/angularjs%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%BA%94%E7%94%A8/"/>
    <id>https://samuelshang.github.io/2017/09/12/angularjs开发过程中的问题及相关应用/</id>
    <published>2017-09-12T02:42:58.000Z</published>
    <updated>2017-11-21T13:28:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>angular 的特性依赖注入<br>依赖注入是一种软件设计模式，目的是处理代码之间的依赖关系，减少组件间的耦合。<br>如果没有使用 AngularJS，定义的时候依赖了，运行的时候不会自动查找依赖项,会报错 Cannot read property ‘get’ of undefined<br>而angularjs可以自动做依赖性的注入。<br>可以显式的使用$inject<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">myApp.controller(&apos;myCtrl&apos;, myCtrl);</span><br><span class="line">function myCtrl = ($scope, $http)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">myCtrl.$inject = [&apos;$scope&apos;, &apos;$http&apos;];</span><br></pre></td></tr></table></figure></p><h1 id="如何刷新当前页面？"><a href="#如何刷新当前页面？" class="headerlink" title="如何刷新当前页面？"></a>如何刷新当前页面？</h1><h1 id="angularjs-在controller-之间的通信的方式主要有三种："><a href="#angularjs-在controller-之间的通信的方式主要有三种：" class="headerlink" title="angularjs 在controller 之间的通信的方式主要有三种："></a>angularjs 在controller 之间的通信的方式主要有三种：</h1><p>1）作用域继承。利用子 Controller 控制父 Controller 上的数据。（父 Controller 中的数据要为引用类型，不能是基本类型）</p><p>2) $rootScope   将数据挂到全局变量上 ，但会造成变量污染</p><p>3）注入服务。把需要共享的数据注册为一个 service，在需要的 Controller 中注入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">angular.module(&apos;demo&apos;)</span><br><span class="line">    .factory(&apos;Data&apos;, function()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        name: &apos;htf&apos;</span><br><span class="line">    &#125;;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p> 各个controller可以注入服务直接使用$scope.data = Data;</p><p>4）基于事件。Angular 为 $scope 提供了冒泡和隧道事件传播机制，$broadcast 会把事件广播给所有子 Controller，而 $emit 则会将事件冒泡传递给父 Controller，$on 则是 Angular的事件监听函数，利用这三者，可以实现上下级和同级（需要构造一个共同的父级 Controller）之间的通信。<br><em>上下级之间</em><br>如果是子 Controller 往父 Controller 上发送事件（从作用域往上发送事件），使用$scope.$emit(“someEvent”, {});<br>如果是父 Controller 往子 Controller 上发送事件（从作用域往下发送事件），使用$scope.$broadcast(“someEvent”, {});<br>无论是 $emit 还是 $broadcast 发送的事件，都用$scope.$on 接收：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$scope.$on(&quot;someEvent&quot;, function(event, data) &#123;</span><br><span class="line">    // 这里取到发送过来的数据 data</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>同级之间利用事件通信有两种方法。一种是利用上下级之间事件传播的变形，另一种是借助 $rootScope 。</p><ul><li>借助父 controller,通过父 Controller 作为中介进行传递的话，子 Controller 触发的事件名和父 Controller 广播用的事件名不能一样，否则会进入死循环。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">.controller(&apos;outerCtrl&apos;, [&apos;$scope&apos;, function($scope)&#123;</span><br><span class="line">    $scope.name = &apos;htf&apos;;</span><br><span class="line">    $scope.$on(&apos;dataChanged&apos;, function(event, data)&#123;</span><br><span class="line">        $scope.name = data;</span><br><span class="line">        // 2. 父 Ctrl 监听到 dataChanged 时间后，触发 changeData 事件</span><br><span class="line">        $scope.$broadcast(&apos;changeData&apos;, data);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;])</span><br><span class="line"></span><br><span class="line">.controller(&apos;innerCtrl1&apos;, [&apos;$scope&apos;, function($scope)&#123;</span><br><span class="line">    $scope.change = function()&#123;</span><br><span class="line">        // 1. 子 Ctrl1 中数据改变之后触发 dataChanged 事件</span><br><span class="line">        $scope.$emit(&apos;dataChanged&apos;, $scope.name);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;])</span><br><span class="line"></span><br><span class="line">.controller(&apos;innerCtrl2&apos;, [&apos;$scope&apos;, function($scope)&#123;</span><br><span class="line">    </span><br><span class="line">    // 3. 监听到 changeData 事件后，改变子 Ctrl2 中 数据</span><br><span class="line">    $scope.$on(&apos;changeData&apos;, function(event, data)&#123;</span><br><span class="line">        $scope.name = data;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;])</span><br></pre></td></tr></table></figure><ul><li>借助 $rootScope</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.controller(&apos;innerCtrlA&apos;, [&apos;$scope&apos;, &apos;$rootScope&apos;, function($scope, $rootScope)&#123;</span><br><span class="line">    $scope.change = function()&#123;</span><br><span class="line">        // 广播事件</span><br><span class="line">        $rootScope.$broadcast(&apos;nameChanged&apos;, $scope.name);</span><br><span class="line">    &#125;</span><br><span class="line">    $rootScope.$on(&apos;nameChanged&apos;, function(event, data)&#123;</span><br><span class="line">        $scope.name = data;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;])</span><br><span class="line"></span><br><span class="line">.controller(&apos;innerCtrlB&apos;, [&apos;$scope&apos;, &apos;$rootScope&apos;, function($scope, $rootScope)&#123;</span><br><span class="line">    $scope.change = function()&#123;</span><br><span class="line">        $rootScope.$broadcast(&apos;nameChanged&apos;, $scope.name);</span><br><span class="line">    &#125;</span><br><span class="line">    // 监听事件</span><br><span class="line">    $rootScope.$on(&apos;nameChanged&apos;, function(event, data)&#123;</span><br><span class="line">        $scope.name = data;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;])</span><br></pre></td></tr></table></figure><p>5）发布-订阅 可避免使用$broadcast,$broadcast广播方法要消耗更多的资源，浪费性能，因为广播事件会深入到该作用域的所有子孙作用域</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">myApp.service(&apos;messageService&apos;,function($rootScope) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    publish:function(name,params) &#123;</span><br><span class="line">      $rootScope.$emit(name,params);</span><br><span class="line">    &#125;,</span><br><span class="line">    subscribe:function(name,listener) &#123;</span><br><span class="line">      $rootScope.$on(name,listener);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">myApp.controller(&apos;home&apos;,function($scope,messageService) &#123;</span><br><span class="line">  $scope.showDialog = false;</span><br><span class="line">  $scope.show = function() &#123;</span><br><span class="line">    messageService.publish(&apos;dialog&apos;,&#123;show:true&#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  messageService.subscribe(&apos;dialog&apos;,function(event,param) &#123;</span><br><span class="line">    $scope.showDialog = param.show</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line">myApp.controller(&apos;dialog&apos;,function($scope,messageService) &#123;</span><br><span class="line">  $scoep.hide = function() &#123;</span><br><span class="line">    messageService.publish(&apos;dialog&apos;,&#123;show:false&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="作用域问题"><a href="#作用域问题" class="headerlink" title="作用域问题"></a>作用域问题</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div ng-controller=&quot;TestCtrl&quot;&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123;name&#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;div ng-if=&quot;show&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; ng-model=&quot;name&quot;&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function TestCtrl($scope)&#123;</span><br><span class="line">    $scope.show = true;</span><br><span class="line">    $scope.name = &apos;htf&apos;;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>把 p 元素和 input 元素绑定同一个变量，你本以为，在输入框输入内容，p 中显示的肯定也是随之变化的。然而并不是这样，不管 input 中的元素怎么变， p 元素中的都没变化，这是什么原因呢。<br>每个 Angular 应用默认有一个根作用域 $rootScope， 根作用域位于最顶层，从它往下挂着各级作用域。<br>原因在于，InnerCtrl 中并未定义 x 这个变量，取值的时候，会沿着原型链向上找，找到了 OuterCtrl 中定义的 x ，然后赋值给自己，在 InnerCtrl 的输入框输入值时，改变的是 InnerCtrl 中的 x ，而对 OuterCtrl 中的 x 无影响。此时，两个 x 是独立的。<br>那么，如果上下级作用域想共用变量怎么办呢？答案是使用引用类型变量。<br>ng-if 中的作用域</p><p>前面讲的是两级控制器之间的作用域，那跟前面提到的问题有什么关系呢？那个看着不是只有一个 Controller 吗？</p><p>其实，并不是只有 Controller 可以创建作用域，ng-if 等指令也会（隐式地）产生新作用域。</p><p>总结下来就是，ng-if、 ng-switch 、 ng-include 等会动态创建一块界面的东西，都是自带一级作用域。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;angular 的特性依赖注入&lt;br&gt;依赖注入是一种软件设计模式，目的是处理代码之间的依赖关系，减少组件间的耦合。&lt;br&gt;如果没有使用 AngularJS，定义的时候依赖了，运行的时候不会自动查找依赖项,会报错 Cannot read property ‘get’ of u
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用地图服务</title>
    <link href="https://samuelshang.github.io/2017/09/12/%E4%BD%BF%E7%94%A8%E5%9C%B0%E5%9B%BE%E6%9C%8D%E5%8A%A1/"/>
    <id>https://samuelshang.github.io/2017/09/12/使用地图服务/</id>
    <published>2017-09-12T02:30:46.000Z</published>
    <updated>2017-09-12T02:37:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="选用适合的第三方地图服务商如百度地图或高德地图"><a href="#选用适合的第三方地图服务商如百度地图或高德地图" class="headerlink" title="选用适合的第三方地图服务商如百度地图或高德地图"></a>选用适合的第三方地图服务商如百度地图或高德地图</h1><p>需要注意的是他们的参考坐标系可能不同，转换起来比较麻烦</p><h1 id="使用方法-："><a href="#使用方法-：" class="headerlink" title="使用方法 ："></a>使用方法 ：</h1><p>1.直接引入<br>    a)在H5页面中使用外链直接导入百度或高德的手机weburl(自己构造<a href="https://m.amap.com/?q=&#39;纬度&#39;,&#39;经度+&#39;&amp;name=&#39;查询地址&#39;" target="_blank" rel="noopener">https://m.amap.com/?q=&#39;纬度&#39;,&#39;经度+&#39;&amp;name=&#39;查询地址&#39;</a>)<br>    b)APP中直接跳转到地图APP<br>2.利用js SDK定制化开发地图服务</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;选用适合的第三方地图服务商如百度地图或高德地图&quot;&gt;&lt;a href=&quot;#选用适合的第三方地图服务商如百度地图或高德地图&quot; class=&quot;headerlink&quot; title=&quot;选用适合的第三方地图服务商如百度地图或高德地图&quot;&gt;&lt;/a&gt;选用适合的第三方地图服务商如百度地
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>angularjs 数据绑定</title>
    <link href="https://samuelshang.github.io/2017/09/12/angularjs-%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/"/>
    <id>https://samuelshang.github.io/2017/09/12/angularjs-数据绑定/</id>
    <published>2017-09-11T23:23:21.000Z</published>
    <updated>2017-09-12T07:51:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单向绑定（ng-bind）和-双向绑定（ng-model）-的区别"><a href="#单向绑定（ng-bind）和-双向绑定（ng-model）-的区别" class="headerlink" title="单向绑定（ng-bind）和 双向绑定（ng-model） 的区别"></a>单向绑定（ng-bind）和 双向绑定（ng-model） 的区别</h1><p>ng-bind 单向数据绑定,用于数据显示，简写形式是双括号。<br>两者的区别在于页面没有加载完毕会直接显示到页面,直到 Angular 渲染该绑定数据（这种行为有可能将让用户看到）;而 ng-bind 则是在 Angular 渲染完毕后将数据显示。<br>ng-model 是双向数据绑定,用于绑定值会变化的表单元素等。</p><h1 id="双向数据绑定的原理"><a href="#双向数据绑定的原理" class="headerlink" title="双向数据绑定的原理"></a>双向数据绑定的原理</h1><p>双向数据绑定意味着当 view 中有任何数据发生变化会自动地反馈到 scope 的数据上，当 scope 模型发生变化，view 中的数据也会更新到最新的值。很显然，这需要一个监控。<br>事实上，AngularJS 确实在幕后为 scope 模型上设置了一个 监听队列，用来监听数据变化并更新 view 。<br>每次绑定一个东西到 view 上时 AngularJS 就会往 $watch 队列里插入一条 $watch，用来检测它监视的 model 里是否有变化的东西。<br>当浏览器接收到可以被 angular context 处理的事件时，$digest 循环就会触发。$digest 会遍历所有的 $watch 。</p><h1 id="一次更新操作至少执行两次digest"><a href="#一次更新操作至少执行两次digest" class="headerlink" title="一次更新操作至少执行两次digest"></a>一次更新操作至少执行两次digest</h1><p>比如click点击操作<br>1.按下按钮<br>2.浏览器接收到一个事件，进入 angular context<br>3.$digest 循环开始执行，查询每个 $watch 是否变化<br>4.由于监视 $scope.val 的 $watch 报告了变化，它会强制再执行一次 $digest 循环。<br>5.新的 $digest 循环没有检测到变化。<br>6.浏览器拿回控制权，更新与 $scope.val 新值相应部分的 DOM 。</p><h1 id="digest-和-apply-的区别"><a href="#digest-和-apply-的区别" class="headerlink" title="$digest()和$apply()的区别"></a>$digest()和$apply()的区别</h1><p>1）最直接的差异是， $apply 可以带参数，它可以接受一个函数，然后在应用数据之后，调用这个函数。所以，一般在集成非 Angular 框架（比如 jQuery）的代码时，可以把代码写在这个里面调用。<br>2）当调用 $digest 的时候，只触发当前作用域和它的子作用域上的监控，但是当调用 $apply 的时候，会触发作用域树上的所有监控。</p><h2 id="需要手动调用apply的场景"><a href="#需要手动调用apply的场景" class="headerlink" title="需要手动调用apply的场景"></a>需要手动调用apply的场景</h2><p>场景一： 使用了 JavaScript 中的 setTimeout() 来更新一个 scope model<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$scope.setMsg = function() &#123;  </span><br><span class="line">    setTimeout(function() &#123;  </span><br><span class="line">        $scope.message = &apos;hello world&apos;;  </span><br><span class="line">        console.log(&apos;message:&apos; + $scope.message);  </span><br><span class="line">    &#125;, 2000);  </span><br><span class="line">&#125;  </span><br><span class="line">$scope.setMsg();</span><br></pre></td></tr></table></figure></p><p>会看到过了两秒钟之后，控制台确实会显示出已经更新的 model，然而，view 并没有更新。正确的做法是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$scope.getMessage = function() &#123;  </span><br><span class="line">    setTimeout(function() &#123;  </span><br><span class="line">        $scope.$apply(function() &#123;  </span><br><span class="line">            $scope.message = &apos;hello world&apos;;   </span><br><span class="line">            console.log(&apos;message:&apos; + $scope.message);  </span><br><span class="line">        &#125;);  </span><br><span class="line">    &#125;, 2000);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>场景二：用指令设置一个 DOM 事件 listener 并且在该 listener 中修改了一些 model<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.directive(&quot;inc&quot;, function() &#123;</span><br><span class="line">    return function (scope, element, attr) &#123;</span><br><span class="line">        element.on(&quot;click&quot;, function() &#123;</span><br><span class="line">            scope.val++;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>在 scope.val++; 一行后面添加 scope.$apply(); 或者 scope.$digest(); 就 OK 了。<br>$scope.$apply() 相当于 $rootScope.$digest()。从另外一个角度，我们也可以看到，为什么调用外部框架的时候，是推荐放在 $apply 中，因为只有这个地方才是对所有数据变更都应用的地方，如果用 $digest，有可能临时丢失数据变更。</p><h1 id="在-AngularJS-中使用-watch"><a href="#在-AngularJS-中使用-watch" class="headerlink" title="在 AngularJS 中使用 $watch"></a>在 AngularJS 中使用 $watch</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$scope.name = &apos;htf&apos;;</span><br><span class="line">$scope.$watch(&apos;name&apos;, function(newValue, oldValue) &#123;</span><br><span class="line">    if (newValue === oldValue) &#123; return; &#125; </span><br><span class="line">    $scope.updated++;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;单向绑定（ng-bind）和-双向绑定（ng-model）-的区别&quot;&gt;&lt;a href=&quot;#单向绑定（ng-bind）和-双向绑定（ng-model）-的区别&quot; class=&quot;headerlink&quot; title=&quot;单向绑定（ng-bind）和 双向绑定（ng-mod
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>观察者模式</title>
    <link href="https://samuelshang.github.io/2017/08/13/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://samuelshang.github.io/2017/08/13/观察者模式/</id>
    <published>2017-08-13T07:57:20.000Z</published>
    <updated>2017-09-12T00:02:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>1、observer [观察者模式]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class StateTracker&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.observers = [];</span><br><span class="line">        this.internalState= 10;</span><br><span class="line">    &#125;</span><br><span class="line">    // 改变内部状态，触发状态的观察者列表</span><br><span class="line">    change(val)&#123;</span><br><span class="line">        this.internalState= val;</span><br><span class="line">        this.observers.forEach(observer=&gt;observer(val));</span><br><span class="line">    &#125;// 注册观察者</span><br><span class="line">    registerObserver(ObserverFn)&#123;</span><br><span class="line">        this.obserers.push(ObserverFn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2、publish/subscribe [订阅发布模式]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class PubSubHandler&#123;</span><br><span class="line">       constructor()&#123;</span><br><span class="line">           this.eventPool = &#123;&#125;;</span><br><span class="line">       &#125;</span><br><span class="line">       //移除</span><br><span class="line">       off(topicName)&#123;</span><br><span class="line">           delete this.observers[topicName]</span><br><span class="line">       &#125;</span><br><span class="line">       //发布</span><br><span class="line">       trigger(topicName,...args)&#123;</span><br><span class="line">           this.eventPool[topicName] &amp;&amp; </span><br><span class="line">           this.eventPool[topicName].forEach(callback=&gt;callback(...args));</span><br><span class="line">       &#125;</span><br><span class="line">       //订阅</span><br><span class="line">       on(topicName,callback)&#123;</span><br><span class="line">           let topic = this.eventPool[topicName] ;</span><br><span class="line">           if(!topic)&#123;</span><br><span class="line">               this.eventPool[topicName] =[]</span><br><span class="line">           &#125;</span><br><span class="line">           this.eventPool[topicName].push(callback)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>3、singleton[单例模式]<br>构造函数的实例只有一个，一般是通过闭包存储内部实例，通过接口访问内部实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var single = () =&gt; &#123;</span><br><span class="line">    var instance;</span><br><span class="line">    var createInstance = () =&gt; &#123;</span><br><span class="line">        this.a = 1;</span><br><span class="line">        this.b = 2;</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">        getInstance:() =&gt; &#123;</span><br><span class="line">            if(!instance) &#123;</span><br><span class="line">                instance = createInstance();</span><br><span class="line">            &#125;</span><br><span class="line">            return instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、observer [观察者模式]&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>闭包</title>
    <link href="https://samuelshang.github.io/2017/08/13/%E9%97%AD%E5%8C%85/"/>
    <id>https://samuelshang.github.io/2017/08/13/闭包/</id>
    <published>2017-08-13T01:33:08.000Z</published>
    <updated>2018-03-15T03:12:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h1><p><strong>闭包是在函数内部可访问的局部变量</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function a() &#123;</span><br><span class="line">    var local = &apos;a&apos;;</span><br><span class="line">    function b() &#123;</span><br><span class="line">        return local++;</span><br><span class="line">    &#125;</span><br><span class="line">    return b  //必须要return 让外部可以访问这个函数</span><br><span class="line">&#125;</span><br><span class="line">var c = a();</span><br><span class="line">c();</span><br></pre></td></tr></table></figure><p>函数嵌套是为了造出一个局部变量</p><h1 id="闭包的作用？"><a href="#闭包的作用？" class="headerlink" title="闭包的作用？"></a>闭包的作用？</h1><ul><li><strong>闭包是为了隐藏变量</strong></li></ul><p>为什么要使用闭包？为了避免变量污染，隐藏全局变量，使用局部变量，但局部变量在函数运行完就回收了外部访问不到，而闭包可以可以延长局部变量的生命周期，在外部也可以访问局部变量。  </p><ul><li><p><strong>用闭包保存状态</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var elems = document.getElementsByTagName(&apos;a&apos;);</span><br><span class="line">for (var i = 0; i &lt; elems.length; i++) &#123;</span><br><span class="line">    elems[i].addEventListener(&apos;click&apos;, function (e) &#123;</span><br><span class="line">        e.preventDefault();</span><br><span class="line">        alert(i);</span><br><span class="line">    &#125;, &apos;false&apos;);</span><br><span class="line">&#125;;</span><br><span class="line">当循环执行以后，我们在点击的时候i才获得数值，最终显示的都是同一个数字</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var elems = document.getElementsByTagName(&apos;a&apos;);</span><br><span class="line">for (var i = 0; i &lt; elems.length; i++) &#123;</span><br><span class="line">    (function (lockedInIndex) &#123;</span><br><span class="line">        elems[i].addEventListener(&apos;click&apos;, function (e) &#123;</span><br><span class="line">            e.preventDefault();</span><br><span class="line">            alert( lockedInIndex);</span><br><span class="line">        &#125;, &apos;false&apos;);</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p></li></ul><h2 id="具体实现："><a href="#具体实现：" class="headerlink" title="具体实现："></a>具体实现：</h2><p>暴露一个访问器（函数），让别人可以「间接访问」…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是闭包？&quot;&gt;&lt;a href=&quot;#什么是闭包？&quot; class=&quot;headerlink&quot; title=&quot;什么是闭包？&quot;&gt;&lt;/a&gt;什么是闭包？&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;闭包是在函数内部可访问的局部变量&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;h
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>前后端分离</title>
    <link href="https://samuelshang.github.io/2017/08/12/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"/>
    <id>https://samuelshang.github.io/2017/08/12/前后端分离/</id>
    <published>2017-08-12T03:18:16.000Z</published>
    <updated>2019-05-10T14:42:11.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 好处</p></blockquote><p>前端倾向于呈现，着重处理用户体验相关的问题；后端则倾处于业务逻辑、数据处理和持久化等。在设计清晰的情况下，后端只需要以数据为中心对业务处理算法负责，并按约定为前端提供 API 接口；而前端使用这些接口对用户体验负责。</p><blockquote><p>缺点</p></blockquote><p>业务处理几乎都是由后端（原来的技术骨干）来设计和定义的，前端处理过程中常常发现接口定义不符合用户操作流程，AJAX 异步请求过多等问题。从前端的角度来看，重点关注的是用户体验，包括用户在进行业务操作时的流动方向和相关处理；而从后端的角度来看，重点关注的是数据完整、有效、安全。接口粒度太小，前端要处理的事情就多，尤其是对各种异步处理就可能会感到应接不暇；粒度太大，就会出现高耦合，降低灵活性和扩展性，当然这种情况下后端的工作就轻松不了。</p><p>前端设计的产品从大的层面可以分成两种：<br>a. 浏览类：以内容展现为主，辅以少量交互，如首页、促销页<br>b. 应用类：包含大量交互，和复杂的功能，如控制台<br> 前后台配合开发通常有以下两种形式：<br>a. 前端完成静态页面，后台改成动态模板（后台渲染并提供数据）<br>b. 前端使用动态模板或 MVVM（AngularJS，Vue） 框架，后台只提供数据（前端渲染，后台提供数据）</p><h1 id="应用类"><a href="#应用类" class="headerlink" title="应用类"></a>应用类</h1><p>对于这种需求，由于前后端是天然分离的，所以做的工作主要是约定好数据的交互，避免后台提供的数据与前端要求的不一致。</p><p>在和后台对接接口的时候，为避免前端配置后台环境，可以使用 Nginx 反向代理，Nginx 监听 80 端口，静态请求由 Nginx 处理，动态请求转发给后端服务。</p><p>MVVM 框架也有自身的缺点，由于模板在浏览器端渲染，会存在空白页、SEO 或性能的问题，而且对浏览器的版本也有要求（IE8 + 或 IE9+），所以，可以根据自己项目的实际情况选择，通常对于管控类项目还是比较合适的。</p><p>另外，使用 MVVM 框架开发大规模 Web App 时，对项目的路由设置、分层、模块划分、代码规范等都有一定要求。</p><h1 id="浏览类"><a href="#浏览类" class="headerlink" title="浏览类"></a>浏览类</h1><p>前端写后台模板<br>通常由前端完成静态页面然后后台来套模板，但后台可能会套错，沟通成本很高。更合适的方式可能是直接由前端写后台模板，但前端又需要配置后台环境，也很麻烦。</p><p>一种解决办法是，使用 Node 实现一套解析后台模板的库，这样前端无需配置后台环境就能写后台模板。比如对于阿里后台用的 Velocity 模板，就有一个 Node 解析的方案，开源的也有百度的 jello。这样前端可以直接预览 vm，并使用 JSON 进行数据模拟，在开发前制定好接口，前后端就可以独立开发。</p><p>中间加一层 Node</p><p>在以往前端后台的中间加一层 Node，这样，浏览器中的前端层和 Node 层由前端人员开发。其中，浏览器层进行 JS、CSS 的渲染和 DOM 等操作，Node 层进行页面渲染、数据转发、路由等操作。而且，Node 层可以和浏览器共用验证、路由等。</p><p>具体的案例可参看淘宝的 中途岛 项目</p><p>这个方案的挑战是，前端人员需要掌握更多服务器端编程的知识。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://my.oschina.net/bobolu/blog/94382" target="_blank" rel="noopener"> Web 前后端研发模式的思考</a><br><a href="http://blog.jobbole.com/65509/" target="_blank" rel="noopener">Web 研发模式的演变</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt; 好处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前端倾向于呈现，着重处理用户体验相关的问题；后端则倾处于业务逻辑、数据处理和持久化等。在设计清晰的情况下，后端只需要以数据为中心对业务处理算法负责，并按约定为前端提供 API 接口；而前端使用这些接
      
    
    </summary>
    
    
  </entry>
  
</feed>
